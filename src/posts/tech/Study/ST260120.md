---
title: 원티드 수업 (인라인함수, 함수호출 원리 / void** / Pointer, delete void*가 불가능한 이유)
date: 2026-01-20T17:34
category: Study
---


## Pointer
delete 명령어는 포인터가 가르키고 있는 메모리 공간을 해제하는 역할만 한다. 따라서 delete 이후에도 포인터 변수 자체에는 이전 주소값이 그대로 남으며 nullptr로 변경되지 않는다. 해당 포인터에 다시 접근하면 *dangling pointer(이전에 해제된 메모리를 가리키는 포인터)*가 되어 프로그램이 비정상 종료될 수 있다. 따라서 delete 후에는 반드시 포인터를 nullptr로 초기화 해야한다.


**다른 함수로 포인터 변수를 넘겨 nullptr화 할 때 주의 할 점이 있다.** int* pointer라는 변수를 만들고, 이 변수를 DeletePointer함수에서 nullptr화 시켜주려고 한다. 이때 매개변수 타입을 int* ptr로 받으면 원본 포인터 pointer는 nullptr이 되지 않는다. **ptr 자체가 스택에 새로 생성된 지역 변수이기 때문이다. ptr = nullptr은 ptr만 nullptr로 만드는 것이고, 원본 pointer의 값은 바뀌지 않는다**

따라서 int** 형태로 매개변수를 받아야 한다. *ptr은 pointer에 들어있는 주소값을 의미하기 떄문에 delete *ptr을 통해 pointer에 저장된 할당된 메모리 영역에 접근하여 해당 메모리 영역을 해제하고, *ptr = nullptr을 통해 스택에 저장된 pointer값도 nullptr이 된다.

```cpp
#include <iostream>

// a bad function
void DeletePointer(int* ptr)
{
	delete ptr;
	ptr = nullptr;
 }

// an working function
void DeletePointer(int** ptr)
{
	delete *ptr;
	*ptr = nullptr;
}

// a better working function
void DeletePointer(int*& ptr)
{
	delete ptr;
	ptr = nullptr;
}

int main()
{
	int* pointer = new int;
	DeletePointer(&pointer);

	return 0;
}
```