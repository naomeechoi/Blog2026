---
title: 원티드 수업 (데이터, ##매크로, 메모리)
date: 2026-01-22T13:44
category: Study
---

## 요약
- [모든 데이터 타입을 수로 치환, 컴퓨터 처럼 생각하기](#1)

	- [ ] [파일을 압축하고 푸는 라이브러리 제작](#2)
	- [ ] [png는 어떻게 저장되서 보여질까](#3)
	- *색을 숫자로 변환해보는 훈련*
- [ ] [## 두 텍스트를 강제로 붙이는 매크로와 w_char](#4)
- [ ] [메모리 할당, 해제 함수는 운영체제 커널의 명령어를 호출한다.](#5)
- *참조는 값 복사를 하지 않을 뿐, 주소 복사는 이루어진다.*
- [ ] [직렬화 역직렬화](#6)
- [ ] [스택의 크기가 무한정으로 커져도 힙이 필요할까?](#7)
- [ ] [new와 malloc의 차이](#8)
- *엘런케이를 이해하면 opp가 이해 된다.*
- [ ] [DDD란](#9)
- *구현이 먼저다.*
- [ ] [보간기/lerp](#10)
- [ ] [벡터의 w는 0, 포지션의 w는 1](#11)
//어떻게 쪼개달라.. 이런걸 넘겼던 것 같은데 
- [ ] [아크단젠트와 아크탄젠트2의 차이, 아탄2는 어떻게 각도를 찾아내나](#12)
- [ ] [const int / const int const](#13)
- [ ] [public 함수는 '메시지'이다.](#14)
- [ ] [유니티 빌드와 인크레빌드](#15)
- [ ] [effective c++ / 자원관리 와 엔진의 자원관리가 다른 점](#16)
- [X] [The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets (No Excuses!)](https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/) [->내용요약](#17)
- [ ] [CppCon 2014: James McNellis "Unicode in C++"](https://www.youtube.com/watch?reload=9&v=n0GK-9f4dl8)
- [ ] [창시자 앨런 케이가 말하는, 객체 지향 프로그래밍의 본질](https://prod.velog.io/@eddy_song/alan-kay-OOP)
- [ ] [수학으로 시작하는 3D 게임 개발](https://product.kyobobook.co.kr/detail/S000001535597?utm_source=google&utm_medium=cpc&utm_campaign=googleSearch&gt_network=g&gt_keyword=&gt_target_id=dsa-1544589326563&gt_campaign_id=9979905549&gt_adgroup_id=132556570510&gad_source=1)
- [ ] [effective c++ / 자원관리](https://product.kyobobook.co.kr/detail/S000001962302)


<br></br>
<a id="1"></a>
## 모든 데이터 타입을 수로 치환, 컴퓨터 처럼 생각하기
	내용을 작성해볼게요
<br></br>
<a id="2"></a>
### 파일을 압축하고 푸는 라이브러리 제작
	내용
<br></br>
<a id="3"></a>
### png는 어떻게 저장되서 보여질까
	내용
<br></br>
<a id="4"></a>
## ## 두 텍스트를 강제로 붙이는 매크로와 w_char
	내용
<br></br>
<a id="5"></a>
## 메모리 할당, 해제 함수는 운영체제 커널의 명령어를 호출한다.
	내용
<br></br>
<a id="6"></a>
## 직렬화와 역직렬화
	- 네트워크 시리얼라이제이션, 파일 시리얼라이제이션 등
	- 메모리에 있는 데이터를 다른 형태로 보내고, 다른 데이터를 메모리로 가져오는 과정을 시리얼라이제이션, 즉 직렬화와 역직렬화라고 한다.
	- 엔진의 초기 단계에서는 파일(직렬화, 역직렬화), 플랫폼, 메모리 관리를 시작하고 그 후 그래픽을 올린다.
	- 언리얼 엔진의 플레이, 스탑 버튼도 해당 씬을 직렬화 하는 것이다.
	- 파서는 직렬화에 포함되는 과정이다.
<br></br>
<a id="8"></a>
## new와 malloc의 차이
	내용
<br></br>
<a id="9"></a>
## DDD란
	내용
<br></br>
<a id="10"></a>
## 보간기/lerp
	내용
<br></br>
<a id="11"></a>
## 벡터의 w는 0, 포지션의 w는 1
	내용
<br></br>
<a id="12"></a>
## 아크단젠트와 아크탄젠트2의 차이, 아탄2는 어떻게 각도를 찾아내나
	-코사인, 사인을 쓰지 않는 이유는 빗변의 길이를 알아내는 것이 번거롭기 때문이다. 따라서 이미 알고 있는 x, y 값으로 만 사용할 수 있는 탄젠트를 많이 사용한다.
<br></br>
<a id="13"></a>
## const int / const int const
	내용
<br></br>
<a id="14"></a>
## public 함수는 '메시지'이다.
	내용
<br></br>
<a id="15"></a>
## 유니티 빌드와 인크레빌드
	내용
<br></br>
<a id="16"></a>
## effective c++ / 자원관리 와 엔진의 자원관리가 다른 점
	내용
<br></br>
<a id="17"></a>
## The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets (내용 요약)
&emsp;문자열을 저장한 바이트만으로는 어떤 글자인지 알 수 없고, 어떤 인코딩으로 저장되었는지 알아야 문자가 제대로 해석될 수 있다. 기존 ASCII는 7비트로 기호 없는 영어 알파벳과 몇몇 기호만 표현 가능했다. 그러나 문자의 크기를 1바이트(8비트)로 오해한 사람들에 의해, 128-255까지의 공간을 각자 다른 용도로 사용했다(ANSI). 이로인해 국가 사이에 문자열을 주고 받을 때 문자열이 깨지는 문제가 생겼다. 글자의 개수가 더욱 많은 아시아권에서는 2바이트를 추가로 이용함으로써 상황이 더 복잡해졌다.
<br><br>
&emsp;이를 해결하기 위해 Unicode가 등장했다. Unicode 자체는 인코딩이 아니다. Unicode는 문자를 표현하는 숫자들의 나열(코드 포인트)을 표현하는 방법이고, 이것을 어떤 바이트 형식으로 저장할 것인지에 대해서는 아직 언급되지 않았다. 따라서 **인코딩이란 코드 포인트를 바이트로 저장하는 방법이다.**
<br><br>
&emsp;처음에는 단순하게 2바이트에 저장하는 UTF-16 방식이 제안되었으나, 00 00 이런 바이트를 앞에서 읽을 것인가 혹은 뒤에서 부터 읽을 것인가 하는 문제가 대두 되었다. 이를 해결하기 위해 BOM(Byte Order Mark)가 등장했다. 그러나 ASCII를 잘 사용해오던 언어 국가의 사람들은 굳이 UTF-16을 쓸 필요가 없었다.
<br><br>
&emsp;이를 해결하기 위해 UTF-8이 등장했다. UTF-8은 ASCII에 정의된 문자들은 그대로 1바이트에 저장하고 나머지 문자들은 2-4바이트에 저장하는 가변길이 인코딩 방식이다.
