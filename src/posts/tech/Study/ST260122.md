---
title: 원티드 수업 (데이터, ##매크로, 메모리)
date: 2026-01-22T13:44
category: Study
---

## 요약
- [모든 데이터 타입을 수로 치환, 컴퓨터 처럼 생각하기](#1)

	- [ ] [파일을 압축하고 푸는 라이브러리 제작](#2)
	- [ ] [png는 어떻게 저장되서 보여질까](#3)
	- *색을 숫자로 변환해보는 훈련*
- [X] [## 두 텍스트를 강제로 붙이는 매크로와 w_char](#4)
- [ ] [메모리 할당, 해제 함수는 운영체제 커널의 명령어를 호출한다.](#5)
- *참조는 값 복사를 하지 않을 뿐, 주소 복사는 이루어진다.*
- [ ] [직렬화 역직렬화](#6)
- [X] [스택의 크기가 무한정으로 커져도 힙이 필요할까?](#7)
- [X] [new와 malloc의 차이](#8)
- *엘런케이를 이해하면 opp가 이해 된다.*
- [ ] [DDD란](#9)
- *구현이 먼저다.*
- [ ] [보간기/lerp](#10)
- [ ] [벡터의 w는 0, 포지션의 w는 1](#11)
//어떻게 쪼개달라.. 이런걸 넘겼던 것 같은데 
- [ ] [아크단젠트와 아크탄젠트2의 차이, 아탄2는 어떻게 각도를 찾아내나](#12)
- [ ] [const int / const int const](#13)
- [ ] [public 함수는 '메시지'이다.](#14)
- [ ] [유니티 빌드와 인크레빌드](#15)
- [ ] [effective c++ / 자원관리 와 엔진의 자원관리가 다른 점](#16)
- [X] [The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets (No Excuses!)](https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/) [->내용요약](#17)
- [ ] [CppCon 2014: James McNellis "Unicode in C++"](https://www.youtube.com/watch?reload=9&v=n0GK-9f4dl8)
- [X] [창시자 앨런 케이가 말하는, 객체 지향 프로그래밍의 본질](https://prod.velog.io/@eddy_song/alan-kay-OOP)
- [ ] [수학으로 시작하는 3D 게임 개발](https://product.kyobobook.co.kr/detail/S000001535597?utm_source=google&utm_medium=cpc&utm_campaign=googleSearch&gt_network=g&gt_keyword=&gt_target_id=dsa-1544589326563&gt_campaign_id=9979905549&gt_adgroup_id=132556570510&gad_source=1)
- [ ] [effective c++ / 자원관리](https://product.kyobobook.co.kr/detail/S000001962302)


<br></br>
<a id="1"></a>
### 모든 데이터 타입을 수로 치환, 컴퓨터 처럼 생각하기
	내용을 작성해볼게요
<br></br>
<a id="2"></a>
### 파일을 압축하고 푸는 라이브러리 제작
	내용
<br></br>
<a id="3"></a>
### png는 어떻게 저장되서 보여질까
	내용
<br></br>
<a id="4"></a>
### ## 두 텍스트를 강제로 붙이는 매크로, #는 들어오는 인풋이 무엇이든 스트링으로 변환
```
#define MYTEXT(val,val2) L##val##val2
wcout << MYTEXT("letstest", "um") << endl;
-> L"letstestum" 으로 변환된다.

#define MYTEXT2(val) #val
wcout << MYTEXT2(wchar_t) << endl;
-> wchar_t가 콘솔에 출력된다.
```
<br></br>
<a id="5"></a>
## 메모리 할당, 해제 함수는 운영체제 커널의 명령어를 호출한다.
	내용
<br></br>
<a id="6"></a>
## 직렬화와 역직렬화
	- 네트워크 시리얼라이제이션, 파일 시리얼라이제이션 등
	- 메모리에 있는 데이터를 다른 형태로 보내고, 다른 데이터를 메모리로 가져오는 과정을 시리얼라이제이션, 즉 직렬화와 역직렬화라고 한다.
	- 엔진의 초기 단계에서는 파일(직렬화, 역직렬화), 플랫폼, 메모리 관리를 시작하고 그 후 그래픽을 올린다.
	- 언리얼 엔진의 플레이, 스탑 버튼도 해당 씬을 직렬화 하는 것이다.
	- 파서는 직렬화에 포함되는 과정이다.
<br></br>
<a id="7"></a>
### 스택의 크기가 무한정으로 커져도 힙이 필요할까?
(나의 생각) 필요하다. 스택은 LIFO의 구조로 만들어진 메모리 공간이다. 따라서 오래 유지되거나 임의 순서로 접근해야 하는 데이터를 처리하기 어렵다. 이런 데이터를 스택에 넣고 사용하려면 현재 필요하지 않지만 위에 쌓인 데이터들을 다 꺼내서 다른 메모리 공간에 임시 저장한 뒤 다시 넣어야 하는 추가 작업이 필요하다. 또한 동적으로 생성되는 객체들을 힙에 쌓으면, 바로 다음에 꺼내지 않아도 될 데이터들이 얼마나 높게 스택에 쌓일지 알 수 없다. 뿐만 아니라 생성 시점과 사용 시점 역시 예측하기 어렵다.
<br></br>
<a id="8"></a>
## new와 malloc의 차이
malloc은 메모리 할당만 해주는 반면,
new는 메모리 할당, 생성자 호출, 타입 정보 크기 계산을 해준다.
그럼에도 malloc을 사용하는 이유는, 메모리의 잦은 할당 해제를 방지하기 위해 큰 블록을 미리 할당하기 위해 사용한다.

**malloc은 실제 타입으로 캐스팅 해줘야한다.**
```
MyClass* p = (MyClass*)malloc(sizeof(MyClass));
```
<br></br>
**생성자는 new (생성공간포인터) 타입(); 으로 호출해준다.**
```
void* raw = std::malloc(sizeof(Test));
Test* t = new (raw) Test(42);
```
<br></br>
<a id="9"></a>
## DDD란
	내용
<br></br>
<a id="10"></a>
## 보간기/lerp
	내용
<br></br>
<a id="11"></a>
## 벡터의 w는 0, 포지션의 w는 1
	내용
<br></br>
<a id="12"></a>
## 아크단젠트와 아크탄젠트2의 차이, 아탄2는 어떻게 각도를 찾아내나
	-코사인, 사인을 쓰지 않는 이유는 빗변의 길이를 알아내는 것이 번거롭기 때문이다. 따라서 이미 알고 있는 x, y 값으로 만 사용할 수 있는 탄젠트를 많이 사용한다.
<br></br>
<a id="13"></a>
## const int / const int const
```
Player* player1 = new Player();
Player* player2 = new Player();

// Player*의 속성을 수정하지 못하게 막는 const
const Player* player3 = player1;
player3->x = 3; // 불가능
player3 = player2; // 가능

// player4 의 메모리 공간에 다른 것을 못 담게 하는 const
Player* const player4 = player1;
player4->x = 3; // 가능
player4 = player2; // 불가능

class Test
{
	// 1번 예시
	int x = 0;
	void Test1() const
	{
		// 안 됌, 끝에 const 붙는 함수는 함수 내부에서 맴버변수 수정 불가
		x = 10; 
	}

	// 2번 예시
	const Player* Test2()
	{
		return this;
	}

	// 안 됌 Test2가 const Player* 를 반환해서 포인터의 속성값 수정 불가하다.
	void DoTest(Player* p)
	{
		test()->x = 10;
	}
}
```
<br></br>
<a id="14"></a>
## public 함수는 '메시지'이다.
	내용
<br></br>
<a id="15"></a>
## 유니티 빌드와 인크레빌드
	내용
<br></br>
<a id="16"></a>
## effective c++ / 자원관리 와 엔진의 자원관리가 다른 점
	내용
<br></br>
<a id="17"></a>
## The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets (내용 요약)
&emsp;문자열을 저장한 바이트만으로는 어떤 글자인지 알 수 없고, 어떤 인코딩으로 저장되었는지 알아야 문자가 제대로 해석될 수 있다. 기존 ASCII는 7비트로 기호 없는 영어 알파벳과 몇몇 기호만 표현 가능했다. 그러나 문자의 크기를 1바이트(8비트)로 오해한 사람들에 의해, 128-255까지의 공간을 각자 다른 용도로 사용했다(ANSI). 이로인해 국가 사이에 문자열을 주고 받을 때 문자열이 깨지는 문제가 생겼다. 글자의 개수가 더욱 많은 아시아권에서는 2바이트를 추가로 이용함으로써 상황이 더 복잡해졌다.
<br><br>
&emsp;이를 해결하기 위해 Unicode가 등장했다. Unicode 자체는 인코딩이 아니다. Unicode는 문자를 표현하는 숫자들의 나열(코드 포인트)을 표현하는 방법이고, 이것을 어떤 바이트 형식으로 저장할 것인지에 대해서는 아직 언급되지 않았다. 따라서 **인코딩이란 코드 포인트를 바이트로 저장하는 방법이다.**
<br><br>
&emsp;처음에는 단순하게 2바이트에 저장하는 UTF-16 방식이 제안되었으나, 00 00 이런 바이트를 앞에서 읽을 것인가 혹은 뒤에서 부터 읽을 것인가 하는 문제가 대두 되었다. 이를 해결하기 위해 BOM(Byte Order Mark)가 등장했다. 그러나 ASCII를 잘 사용해오던 언어 국가의 사람들은 굳이 UTF-16을 쓸 필요가 없었다.
<br><br>
&emsp;이를 해결하기 위해 UTF-8이 등장했다. UTF-8은 ASCII에 정의된 문자들은 그대로 1바이트에 저장하고 나머지 문자들은 2-4바이트에 저장하는 가변길이 인코딩 방식이다.
