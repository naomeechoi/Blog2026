---
title: 원티드 수업 (콘솔 엔진 제작: RTTI 자체 제작)
date: 2026-01-28T09:06
category: Study
---
## 콘솔 엔진 제작
<details>
<summary><span style="font-size: 25px; font-weight: 700; color: blue">1) RTTI 자제 제작</span></summary>

### 1) 상속과 매크로를 이용한 RTTI 구현
  - RTTI.h:
   ```
   #pragma once
#include "Common/Common.h"

namespace Wanted
{
	// 커스텀 RTTI를 제공하는 클래스의 최상위 클래스
	class NAOMI_API RTTI
	{
	public:
		virtual const size_t& GetType() const = 0;

		virtual bool Is(RTTI* const rtti) const
		{
			return false;
		}

		virtual bool Is(const size_t id) const
		{
			return false;
		}

		template<typename T>
		T* As()
		{
			if (Is(T::TypeIdClass()))
			{
				return (T*)this;
			}

			return nullptr;
		}

		template<typename T>
		const T* As() const
		{
			if (Is(T::TypeIdClass()))
			{
				return (T*)this;
			}

			return nullptr;
		}
	};

}

// RTTI를 선언할 클래스에 추가할 매크로.
// 아래 코드에서 Type, ParentType이 실제 타입으로 변환되어 복사/붙여넣기 됨.
#define RTTI_DECLARATIONS(Type, ParentType)												\
friend class RTTI;																		\
protected:																				\
	static const size_t TypeIdClass()													\
	{																					\
		static int runTimeTypeId = 0;													\
		return reinterpret_cast<size_t>(&runTimeTypeId);								\
	}																					\
public:																					\
	virtual const size_t& GetType() const override { return Type::TypeIdClass(); }		\
	using super = ParentType;															\
	virtual bool Is(const size_t id) const override										\
	{																					\
		if (id == TypeIdClass())														\
		{																				\
			return true;																\
		}																				\
		else																			\
		{																				\
			return ParentType::Is(id);													\
		}																				\
	}																					\
	virtual bool Is(RTTI* const rtti) const override									\
	{																					\
		return Is(rtti->GetType());														\
	}
   ```
  - Actor.h
   ```
   #pragma once
#include "Common/RTTI.h"

namespace Wanted
{
	class NAOMI_API Actor : public RTTI
	{
		// RTTI 코드 추가
		RTTI_DECLARATIONS(Actor, RTTI)
	public:
		Actor();
		virtual ~Actor();

		virtual void BeginPlay();
		virtual void Tick(float deletaTime);
		virtual void Draw();

		inline bool HasBeganPlay() const { return hasBeganPlay; }
		inline bool IsActive() const { return isActive && !destroyRequested; }
		inline bool DestroyRequested() const { return destroyRequested; }

	protected:
		bool hasBeganPlay = false;
		bool isActive = true;
		bool destroyRequested = false;
	};
}
   ```  
</details>

<br></br>
## 수업 중 배운 내용 요약
- [X] [비쥬얼스튜디오 속성에 넣은 전처리 정의는 어떻게 처리될까?](#1)
- [X] [static_cast, reinterpret_cast, dynamic_cast](#2)
- [X] [dynamic_cast 예시](#3)
- [X] [객체의 포인터, 레퍼런스 형태는 형변환 가능하지만 객체는 불가능하다.](#4)
- [X] [프로그램에서 파일은 어떻게 읽을까?](#5)
- [X] [텍스트 b모드로 읽을 때와 t모드로 읽을 때 차이점](#6)
- [게임 프로그래머를 위한 C++](https://product.kyobobook.co.kr/detail/S000000832646)
- [jonathan blow game engine programming](https://youtu.be/Fl3CV7L6faQ?si=3RoTzf1r3kDkZE1Z)



<br></br>
<a id="1"></a>
### 비쥬얼스튜디오 속성에 넣은 전처리 정의는 어떻게 처리될까?
비쥬얼스튜디오 도구 -> 옵션 -> 빌드 및 실행에서 빌드출력 세부정보 표시를 진단으로 하면, 빌드 상세정보를 출력창에서 확인가능하다.
아래가 컴파일러 실행하는 명령줄이다.   
   ```
1>    C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\bin\HostX64\x64\CL.exe /c /IC:\Workspace\Naomi\ConsoleEngine\Engine\\ /ZI /JMC /nologo /W3 /WX- /diagnostics:column /sdl /Od /D ENGINE_BUILD_DLL /D _DEBUG /D _CONSOLE /D _WINDLL /D _UNICODE /D UNICODE /Gm- /EHsc /RTC1 /MDd /GS /fp:precise /Zc:wchar_t /Zc:forScope /Zc:inline /permissive- /Fo"C:\Workspace\Naomi\ConsoleEngine\Intermediate\x64\Debug\Engine\\" /Fd"C:\Workspace\Naomi\ConsoleEngine\Intermediate\x64\Debug\Engine\vc143.pdb" /external:W3 /Gd /TP /FC /errorReport:prompt Actor\Actor.cpp Core\Input.cpp Engine\Engine.cpp Level\Level.cpp
```
**/D ENGINE_BUILD_DLL** 안에서 이걸 확인할 수 있는데, 이게 비쥬얼스튜디오 속성에 넣은 전처리 정의 중 하나인 ENGINE_BUILD_DLL 이다. 이렇게 컴파일을 실행할 때 /D 옵션 뒤에 붙어 들어간다.
<br></br>
<a id="2"></a>
### static_cast, reinterpret_cast, dynamic_cast
- static_cast  
   - static_cast는 RTTI(실행 시간에 타입 검사)를 쓰지 않고 연관 있는지만 확인하기 때문에 속도가 비교적 빠르다. 
   - 클래스간 변환할 때 상속 관계에 있는가 정도는 확인을 한다.
- reinterpret_caset  
   - 보통 void* 타입으로 모든 타입을 받고, 원래의 타입으로 돌이킬 때 사용한다.
   - 포인터를 void* 변환할 때는 형변환하지 않아도 된다. 타입정보는 그 주소에서 시작해 얼마만큼의 크기의 메모리를 접근할 수 있는지 확인할 수 있는 정보이다. 예를 들어 int면 시작 주소부터 4바이트, char면 1바이트, 클래스는 클래스마다 다름, void*로 변환하면 그 크기를 더이상 알 수 없는 상황이 된다.
- dynamic_cast  
   - dynamic_cast는 vtable을 필요로한다. vtable은 가상함수가 하나 이상 있어야 만들어진다. 따라서 가상함수가 없는 클래스는 dynamic_cast가 불가능하다.
   - typeid 처럼 타입을 확인할 때는 vtable이 필요하지 않을 수 있다. 컴파일러가 타입정보를 메타데이터로 저장 가능하기 때문이다. 그러나 dynamic_cast는 런타임에 상속 관계를 확인해야 하므로 vtable이 필요하다.
   
<br></br>
<a id="3"></a>
### dynamic_cast 예시
불가능
   ```
class A {
	virtual void Test() {};
};

class B : public A{
};

int main()
{
	A* a = new A();
	B* b = new B();

	// A는 B보다 작은 타입 B가 될 수 없다.
	a = dynamic_cast<B*>(a);
	// b = dynamic_cast<B*>(a); 이것도 불가, 어디에 담는가는 상관 없음 캐스트 자체 안 됌
	if (!a)
	{
		// 여기 들어옴
		std::cout << "a is null" << std::endl;
	}
}
   ```  
   가능
   ```
A* aa = new B();
B* bb = new B();
// aa의 실제 타입이 B이기 때문에 가능하다.
bb = dynamic_cast<B*>(aa);
```  

<br></br>
<a id="4"></a>
### 객체의 포인터, 레퍼런스 형태는 형변환 가능하지만 객체는 불가능하다.
스택 객체는 타입이 고정된 실체라 형변환이 불가능하다. 하지만 포인터는 메모리를 해석하는 방법이 바뀌는 것이기 때문에 가능하다.  
   ```
struct A { int x; };
struct B { double y; };

A a;
B b = (B)a;
-> a는 고정된 값인데, 이를 A를 B로 바꿀 수 있는 규칙이 없음

A a;
B* b = (B*)&a;
-> a 포인터를 B* 형태로 해석하겠다는 말이라 문법적으로는 가능하나, 어떤 행동을 할지 보장되지 않음.
```  
   ```
#include <iostream>
using namespace std;

class A {
public:
	int b = 50;
};

class B{
public:
	int a = 20;
	int c = 10;
};

int main()
{
	A a;
	B* b = (B*)&a;
	cout << b->a << endl; -> 이 값은 50이 찍힘 다행이 여기까지는 메모리 공간 크기가 맞기 때문에
	cout << b->c << endl; -> 여기는 메모리 공간을 벗어난 상태라 쓰래기 값이 찍힌다.
}
```  
<br></br>
<a id="5"></a>
### 프로그램에서 파일은 어떻게 읽을까?
프로그램이 fread()와 같은 함수를 통해 읽기 요청을 하면, C 런타임 라이브러리가 내부적으로 OS API를 호출한다. os가 디스크에서 파일을 읽어 커널 버퍼에 데이터를 저장한다. C 런타임 라이브러리의 file 객체의 내부 버퍼로 복사된 후, 최종적으로 프로그램에서 선언한 buffer변수에 쓰이게 된다.
fwrite()를 할 떄도, file 객체 내부->커널버퍼->파일디스크 순으로 쓰이게 된다.
<br></br>
<a id="6"></a>
### 텍스트 b모드로 읽을 때와 t모드로 읽을 때 차이점
   ```
fopen_s(&file, "Test.txt", "r+b");
fopen_s(&file, "Test.txt", "r+t");
```
t는 텍스트로 읽고 b는 바이트로 읽는다는 뜻으로
b로 읽으면 개행이 \r\n 으로
t는 \r을 자동으로 떼준다.

<br></br>