---
title: 원티드 수업 (콘솔 엔진 제작: )
date: 2026-01-28T09:06
category: Study
---
## 콘솔 엔진 제작
<details>
<summary><span style="font-size: 25px; font-weight: 700; color: blue">1) DLL 사용 하기</span></summary>

### 1) DLL을 만들 프로젝트에서 해줘야 할일
- 프로젝트 속성 -> 구성 속성 -> 일반 -> 구성 형식을 DLL로 변경한다.
- 헤더 파일들에는 __declspec(dllexport) 키워드를 붙여줘야 한다.
- 헤더 파일과 DLL, LIB을 EXE 쪽에서 사용 해야함으로 해당 파일들을 특정 경로에 저장한다.
- 저장을 편하게 하기 위해 빌드 전, 후 이벤트를 이용해 명령을 넣어준다.
  - 빌드 전 이벤트:
   ```
   // 헤더 파일들 ..\Includes\Engine\ 경로에 저장
   xcopy *.h ..\Includes\Engine\ /e /y
   ```
  - 빌드 후 이벤트:
   ```
   // dll과 lib을 ..\Library\Engine\ 경로 아래 플렛폼, debug/release 버전에 따라 각각 저장
   xcopy "$(OutDir)\Engine.dll" "..\Library\Engine\$(Platform)\$(Configuration)\" /y /i
   xcopy "$(OutDir)\Engine.lib" "..\Library\Engine\$(Platform)\$(Configuration)\" /y /i
   ```  

### 2) DLL을 임포트하는 프로젝트에서 해줘야 할 일
- dll을 사용하기 위해서는 헤더 파일, dll 파일, lib 파일이 필요하다.
- dll을 사용하기 위한 프로젝트 속성 맞춰주기
1) dll을 만들기 위해 사용된 헤더파일들을 가져온다.
2) 프로젝트 속성 -> C/C++ -> 일반 -> 추가 포함 디렉토리에 헤더파일들이 있는 경로을 넣는다.</br>
예) ..\Includes\Engine (헤더 파일들은 각각의 디렉토리에 맞춰 이 경로에 들어가 있음 C:\Workspace\Naomi\Naomi_Game\Includes\Engine)
   ```
   // 이렇게 하면 코드에서 보다 짧은 구문으로 헤더 인클루드 하여 사용 가능
   #include "Engine/Engine.h"
   #include "Level/TestLevel.h"
   ```
3) 프로젝트 속성 -> 링커 -> 입력 -> 추가 종속성에 사용하려는 dll의 lib 파일을 넣어준다.  

   예) Engine.lib  
   
    <img src="/Img/link_lib.png" alt="Engine.lib" style="width:50%;" />  

4) 프로젝트 속성 -> 링커 -> 일반 -> 추가 라이브러리 디렉터리에 lib 파일을 찾을 경로를 넣어준다.  

   예) ..\Library\Engine\$(Platform)\$(Configuration)\  
   
    <img src="/Img/add_dir_lib.png" alt="라이브러리경로추가" style="width:50%;" />  

5) 사용할 dll 파일은 최종적으로 exe 파일과 같은 곳에 위치 해야한다. 이를 위해 dll을 OutDir에 복사해야한다. 손 복사를 피하기 위해 프로젝트 속성에서 설정한다. 프로젝트 속성 -> 빌드 이벤트 -> 빌드 후 이벤트 -> 명령줄에 입력한다.  

   예) xcopy ..\Library\Engine\$(Platform)\$(Configuration)\Engine.dll $(OutDir)\ /y /i  

    <img src="/Img/after_build.png" alt="빌드후이벤트" style="width:50%;" />
</details>

<br></br>
## 수업 중 배운 내용 요약
- [X] [비쥬얼스튜디오 속성에 넣은 전처리 정의는 어떻게 처리될까?](#1)
- [X] [static_cast, reinterpret_cast, dynamic_cast](#2)
- [X] [dynamic_cast 예시](#3)
- [X] [객체의 포인터, 레퍼런스 형태는 형변환 가능하지만 객체는 불가능하다.](#4)
- [게임 프로그래머를 위한 C++](https://product.kyobobook.co.kr/detail/S000000832646)



<br></br>
<a id="1"></a>
### 비쥬얼스튜디오 속성에 넣은 전처리 정의는 어떻게 처리될까?
비쥬얼스튜디오 도구 -> 옵션 -> 빌드 및 실행에서 빌드출력 세부정보 표시를 진단으로 하면, 빌드 상세정보를 출력창에서 확인가능하다.
아래가 컴파일러 실행하는 명령줄이다.   
   ```
1>    C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\bin\HostX64\x64\CL.exe /c /IC:\Workspace\Naomi\ConsoleEngine\Engine\\ /ZI /JMC /nologo /W3 /WX- /diagnostics:column /sdl /Od /D ENGINE_BUILD_DLL /D _DEBUG /D _CONSOLE /D _WINDLL /D _UNICODE /D UNICODE /Gm- /EHsc /RTC1 /MDd /GS /fp:precise /Zc:wchar_t /Zc:forScope /Zc:inline /permissive- /Fo"C:\Workspace\Naomi\ConsoleEngine\Intermediate\x64\Debug\Engine\\" /Fd"C:\Workspace\Naomi\ConsoleEngine\Intermediate\x64\Debug\Engine\vc143.pdb" /external:W3 /Gd /TP /FC /errorReport:prompt Actor\Actor.cpp Core\Input.cpp Engine\Engine.cpp Level\Level.cpp
```
**/D ENGINE_BUILD_DLL** 안에서 이걸 확인할 수 있는데, 이게 비쥬얼스튜디오 속성에 넣은 전처리 정의 중 하나인 ENGINE_BUILD_DLL 이다. 이렇게 컴파일을 실행할 때 /D 옵션 뒤에 붙어 들어간다.
<br></br>
<a id="2"></a>
### static_cast, reinterpret_cast, dynamic_cast
- static_cast  
   - static_cast는 RTTI(실행 시간에 타입 검사)를 쓰지 않고 연관 있는지만 확인하기 때문에 속도가 비교적 빠르다. 
   - 클래스간 변환할 때 상속 관계에 있는가 정도는 확인을 한다.
- reinterpret_caset  
   - 보통 void* 타입으로 모든 타입을 받고, 원래의 타입으로 돌이킬 때 사용한다.
   - 포인터를 void* 변환할 때는 형변환하지 않아도 된다. 타입정보는 그 주소에서 시작해 얼마만큼의 크기의 메모리를 접근할 수 있는지 확인할 수 있는 정보이다. 예를 들어 int면 시작 주소부터 4바이트, char면 1바이트, 클래스는 클래스마다 다름, void*로 변환하면 그 크기를 더이상 알 수 없는 상황이 된다.
- dynamic_cast  
   - dynamic_cast는 vtable을 필요로한다. vtable은 가상함수가 하나 이상 있어야 만들어진다. 따라서 가상함수가 없는 클래스는 dynamic_cast가 불가능하다.
   - typeid 처럼 타입을 확인할 때는 vtable이 필요하지 않을 수 있다. 컴파일러가 타입정보를 메타데이터로 저장 가능하기 때문이다. 그러나 dynamic_cast는 런타임에 상속 관계를 확인해야 하므로 vtable이 필요하다.
   
<br></br>
<a id="3"></a>
### dynamic_cast 예시
불가능
   ```
class A {
	virtual void Test() {};
};

class B : public A{
};

int main()
{
	A* a = new A();
	B* b = new B();

	// A는 B보다 작은 타입 B가 될 수 없다.
	a = dynamic_cast<B*>(a);
	// b = dynamic_cast<B*>(a); 이것도 불가, 어디에 담는가는 상관 없음 캐스트 자체 안 됌
	if (!a)
	{
		// 여기 들어옴
		std::cout << "a is null" << std::endl;
	}
}
   ```  
   가능
   ```
A* aa = new B();
B* bb = new B();
// aa의 실제 타입이 B이기 때문에 가능하다.
bb = dynamic_cast<B*>(aa);
```  

<br></br>
<a id="4"></a>
### 객체의 포인터, 레퍼런스 형태는 형변환 가능하지만 객체는 불가능하다.
스택 객체는 타입이 고정된 실체라 형변환이 불가능하다. 하지만 포인터는 메모리를 해석하는 방법이 바뀌는 것이기 때문에 가능하다.  
   ```
struct A { int x; };
struct B { double y; };

A a;
B b = (B)a;
-> a는 고정된 값인데, 이를 A를 B로 바꿀 수 있는 규칙이 없음

A a;
B* b = (B*)&a;
-> a 포인터를 B* 형태로 해석하겠다는 말이라 문법적으로는 가능하나, 어떤 행동을 할지 보장되지 않음.
```  
   ```
#include <iostream>
using namespace std;

class A {
public:
	int b = 50;
};

class B{
public:
	int a = 20;
	int c = 10;
};

int main()
{
	A a;
	B* b = (B*)&a;
	cout << b->a << endl; -> 이 값은 50이 찍힘 다행이 여기까지는 메모리 공간 크기가 맞기 때문에
	cout << b->c << endl; -> 여기는 메모리 공간을 벗어난 상태라 쓰래기 값이 찍힌다.
}
```  
<br></br>

