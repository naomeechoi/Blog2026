---
title: 원티드 수업 (콘솔 엔진 제작: 레벨과 액터 구조 추가)
date: 2026-01-26T09:09
category: Study
---
## 콘솔 엔진 제작
<details>
<summary><span style="font-size: 25px; font-weight: 700; color: blue">1) 레벨과 액터 구조 추가</span></summary>

### 1) 레벨 클래스
레벨 클래스는 레벨에 있는 모든 오브젝트를 관리하는 클레스이다.

메인에서 기본 레벨 클래스를 상속 받은 새로운 레벨을 생성한다.
엔진이 멤버 변수로 이 레벨을 전달해준다.
엔진의 BeginPlay는 레벨->BeginPlay를 호출한다.
레벨->BeginPlay는 소유하고 있는 액터들을 돌며 BeginPlay를 호출한다.
BeginPlay가 이미 호출된 함수는 건너 뛰어진다.
같은 방법으로 레벨에서 Actor들의 Tick과 Draw를 호출한다.


### 2) 액터 클래스
게임에 들어가는 오브젝트들을 말한다.

특정 레벨 클래스의 생성자에서 Actor를 상속 받은 특정 actor를 생성하고,
Level의 AddNewActor에 이 객체를 넘겨 벡터에서 관리될 수 있게 한다.

Level에서 Actor들 동작을 위한 BeginPlay, Tick, Draw를 호출한다.
</details>

<br></br>
## 수업 중 배운 내용 요약
- [X] [전역 변수에 쓰이는 extern](#1)
- [X] [업캐스팅과 다운캐스팅](#2)
- [X] [상속의 메모리적 접근, 업캐스팅이 왜 안전한가?](#3)
- [X] [is-a 관계와 has-a 관계](#4)
- [X] [cpu가 데이터 접근을 할 때 코드 영역, 데이터 영역, 스택영역, 힙 영역 어디에 저장되어 있는지 알고 접근을 할까?](#5)
- [X] [참조 타입 / 객체 타입](#6)
- [X] [순수 가상 함수의 함수들이 Public으로 정의 되어야 하는 이유](#7)
- [X] [내부에서 멤버 변수를 바꾸지 않기 위한 const 함수  안에서 콜하는 함수도 const 형이어야 한다.](#8)
- [X] [상속 할 때는 부모 클래스의 형태를 알아야하기 때문에 헤더를 인클루드 해야한다.](#9)
- [클린 코드](https://product.kyobobook.co.kr/detail/S000001032980)
- [리팩토링](https://product.kyobobook.co.kr/detail/S000001810241)



<br></br>
<a id="1"></a>
### 전역 변수에 쓰이는 extern
어떤 cpp파일에 이미 정의 되어 있는 전역변수를, 다른 cpp에서 가져오려면 extern 키워드를 사용하면 된다. 컴파일은 파일 단위로 하므로 extern 키워드가 앞에 적혀 있으면 해당 파일 내에서 값이 대입되지 않았을지라도 정상적으로 컴파일 하고 넘어간다. 실제 값은 링커 단계에서 들어간다.
<br></br>
<a id="2"></a>
### 업캐스팅과 다운캐스팅
업캐스팅은 부모로 형변환 -> 항상 안전하다.
다운캐스팅은 자식으로 형변환 -> 항상 안전하지 않다.
<br></br>
<a id="3"></a>
### 상속의 메모리적 접근, 업캐스팅이 왜 안전한가?
실제 객체 크기는 그대로 두고, 참조 타입을 부모의 타입로 변환해 실제 접근 가능한 메모리 공간을 제한한다. 다운 캐스팅은 안전하지 않으므로 최대한 쓰지 않는게 좋다.
보통 자식 클래스를 부모 클래스로 치환하다가 다시 자기 형태로 돌아올 때 사용한다.

<br></br>
<a id="4"></a>
### is-a 관계와 has-a 관계
is-a는 부모 자식 관계를 의미한다.
has-a는 말 그대로 소유, 예를 들어 아래처럼 소유 관계의 상속을 의미한다.
class developer : public computer
멤버 변수로 클래스를 갖고 있을 때도 has-a 관계라고 할 수 있다.
즉, 어떤 기능을 사용할 때 물려 받을 수도 있지만 소유할 수 도 있다.
```
class Worker
{
	Worker(Computer* computer)
	: computer(computer) {};

	void Work()
	{
		computer->run();
	}

	Computer* computer = nullptr;
}

int main()
{
	// dependency injection 의존성 주입
	// Dependency Inversion Principle, SOLID 패턴 중 하나
	Computer* computer = new Computer();
	Worker worker = new Worker(computer);
	delete computer;
	computer = nullptr;
}
```
<br></br>
<a id="5"></a>
### cpu가 데이터 접근을 할 때 코드 영역, 데이터 영역, 스택 영역, 힙 영역 어디에 저장되어 있는지 알고 접근을 할까?
모른다. cpu는 주소만 보고 메모리에 접근한다.
컴파일러와 링커 과정에서 코드와 데이터가 분리된다.
```
예)
코드 영역 .text
전역/정적데이터 -> .data, .bss
상수 문자열 -> .rodata
```
그리고 프로세스가 만들어질 때, 운영체제가 가상 주소 공간을 코드 영역, 데이터 영역, 힙 영역, 스택 영역으로 구분한다.

CPU가 가상 메모리 주소로 접근하려 할 때, MMU(Memory Management Unit) 장치가 가상 주소를 실제 물리 주소로 변환한다.
- 스택 오버플로어: os가 스택 끝에 가드 페이지를 둔다. cpu가 스택 오버플로어인지 판단하는게 아니라 os가 막아 놓은 페이지가 침범되면 예외가 터지는 것이다. 
- 가상 메모리 주소 왜 쓰지?

  - 프로세스가 중복된 주소 공간을 쓰더라도 실제 메모리 공간 충돌을 방지할 수 있다.
  - 실제 물리 메모리가 단편화 되어 있더라도 이를 연속적인 것처럼 사용할 수 있게 한다.
  - 메모리 부족시 하드 디스크를 활용하여(스와핑 기술) 메모리 공간을 크게 사용할 수 있다.
  - 메모리 공간을 안전하게 사용할 수 있다. 메모리는 페이지라는 단위로 나눠져 있고, 이 페이지에 대한 정보는 페이지 테이블에 저장되어 있다. 페이지 테이블에는 가상주소, 물리주소, 권한이 적혀 있다. cpu가 메모리로 접근하려 할 때 MMU는 페이지 테이블을 통해 실제 물리주소를 얻어온다. 해당 테이블을 통해 특정 페이지가 쓰기/읽기/실행 중 어떤 권한이 있는지도 확인 가능하다.
<br></br>
<a id="6"></a>
### 참조 타입 / 객체 타입
객체 타입은 실제로 생성된 타입을 이야기하고, 참조 타입은 '바라보는 타입'을 이야기한다. 컴파일은 실제 객체가 어떤 타입이든 참조 타입으로 검사를 하고, 참조 타입에 정의된 멤버만 접근 가능하게 한다.

따라서 아래의 경우에,
```
Entity* entity = new Entity();
Entity* player = new Player();
```
player는 Entity의 멤버에 대해서만 접근이 가능하다. **그러나, Entity에 어떤 함수가 virtual로 선언되고, Player가 이 함수를 override 했을 경우 오버라이드된 함수가 불린다. 그러나!!!! 참조 타입인 Entity에 정의되지 않은 함수는 player를 통해 부를 수 없다.**
<br></br>
<a id="7"></a>
### 순수 가상 함수의 함수들이 Public으로 정의 되어야 하는 이유
-반드시 재정의 되어야 하는 함수이므로 public으로 쓴다. (그럼 protected 써도 되잖아?) **인터페이스는 외부 객체와 소통하기 위해, 외부 객체에서 접근하기 위해 나온 기법이기 때문에 public으로 함수를 정의 해야한다.**

```
void GameLoop(std::vector<IUpdatable*> objects, float dt)
{
    for (auto obj : objects)
        obj->Update(dt);  // 외부에서 호출
}
```
<br></br>
<a id="8"></a>
### 내부에서 멤버 변수를 바꾸지 않기 위한 const 함수  안에서 콜하는 함수도 const 형이어야 한다.
```
void Level::Draw() const
{
	for (const Actor* actor : actors)
	{
		actor->Draw();
	}
}
```
<br></br>
<a id="9"></a>
### 상속 할 때는 부모 클래스의 형태를 알아야하기 때문에 헤더를 인클루드 해야한다.
```
#include "Level.h"

class TestLevel : public Wanted::Level
{
public:
	TestLevel();
};
```
<br></br>