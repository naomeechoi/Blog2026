---
title: 원티드 수업 (콘솔 엔진 제작: )
date: 2026-01-26T09:09
category: Study
---
## 콘솔 엔진 제작
<details>
<summary><span style="font-size: 25px; font-weight: 700; color: blue">1) 프레임 레이트</span></summary>

### 1) 프레임 레이트와 필요성
프레임 레이트는 1초에 화면이 새로 그려지는 횟수 의미한다. 60FPS는 1초에 60프레임이 그려지는 것이다. 프레임 레이트 계산 방식은 여러가지가 있다. 대표적으로 고정 프레임 레이트 계산 방식과 가변 프레임 레이트 계산 방식이 있다.
<br></br>
프레임 레이트는  컴퓨터의 사양을 측정할 수 있는 도구이자 게임 화면을 렌더링하기 위한 기준이 된다. 컴퓨터의 속도는 컴퓨터 마다 다르다. 따라서 프레임 레이트를 고정하면 어떤 컴퓨터에서는 게임이 매우 빠르게 렌더링되고, 어떤 컴퓨터에서는 그렇지 못하다. 따라서 렌더링은 가변 프레임에 따라, 물리/로직 업데이트는 고정 타임스텝으로 처리한다.
### 2) 프레임 레이트 계산 방법과 함수
아래 코드는 '가변 프레임 레이트 + 최대 프레임 제한'을 합친 방식이다.
oneFrameTime이 최대 프레임으로 oneFrameTime 프레임 이상은 되어야 렌더링한다. 프레임 레이트가 일정 속도 이상으로 빨라지는 것을 방지한다. QueryPerformanceCounter 함수는 보다 정밀하게 시간을 측정하는 함수로, OS가 실행된 이후부터의 tick을 센다. QueryPerformanceFrequency는 1초에 tick이 몇 번 발생하는 지 리턴한다. (1000번 발생한다면 1초에 1000묶음이 실행되는 것) 따라서 deltaTime = (float)(currentTime - previousTime)을 frequency로 나누면 1000묶음이 몇 개인지 알 수 있고 이게 곧 n초를 의미한다. 
```
	LARGE_INTEGER frequency;
	QueryPerformanceFrequency(&frequency);

	int64_t currentTime = 0;
	int64_t previousTime = 0;

	// 기준 프레임 (단위: 초)
	float targetFrameRate = 120.0f;
	float oneFrameTime = 1.0f / targetFrameRate;

	LARGE_INTEGER time;
	QueryPerformanceCounter(&time);

	// loop 진입 전에는 두 시간을 동일하게 맞춘다.
	currentTime = time.QuadPart;
	previousTime = currentTime;

	while (!isQuit)
	{
		// 현재 시간 계산
		QueryPerformanceCounter(&time);
		currentTime = time.QuadPart;

		// 프레임 시간 계산
		float deltaTime = (float)(currentTime - previousTime);
		// 초단위 변환
		deltaTime /= (float)frequency.QuadPart;

		if (deltaTime >= oneFrameTime)
		{
			// 프레임 처리
			Tick(deltaTime);
			Draw();

			previousTime = currentTime;
		}
	}
```
```
const float fixedDeltaTime = 1.0f / 60.0f;
float accumulator = 0.0f;

while (running)
{
    float deltaTime = GetDeltaTime();
    accumulator += deltaTime;

    // 물리/로직은 고정 시간 간격으로 여러 번 업데이트
    while (accumulator >= fixedDeltaTime)
    {
        UpdatePhysics(fixedDeltaTime);
        accumulator -= fixedDeltaTime;
    }

    // 렌더링은 실제 프레임으로
    Render();
}
```
</details>
<details>
<summary><span style="font-size: 25px; font-weight: 700; color: blue">2) 키보드 인풋</span></summary>

### 1) 프레임 레이트란
접은 내용
### 2) 프레임 레이트 계산 방법과 함수
접은 내용
```
// 코드 영역
```
### 3) 프레임 레이트 제한이 필요한 이유
접은 내용
```
// 코드 영역
```
</details>

<br></br>
## 수업 중 배운 내용 요약
- [X] [전역 변수에 쓰이는 extern](#1)
- [X] [업캐스팅과 다운캐스팅](#2)
- [X] [상속의 메모리적 접근, 업캐스팅이 왜 안전한가?](#3)
- [X] [is-a 관계와 has-a 관계](#4)
- [X] [cpu가 데이터 접근을 할 때 코드 영역, 데이터 영역, 스택영역, 힙 영역 어디에 저장되어 있는지 알고 접근을 할까?](#5)
- [X] [참조 타입 / 객체 타입](#6)
- [] [참조 타입 / 객체 타입](#7)
- [] [참조 타입 / 객체 타입](#8)
- [] [참조 타입 / 객체 타입](#9)
- [클린 코드](https://product.kyobobook.co.kr/detail/S000001032980)



<br></br>
<a id="1"></a>
### 전역 변수에 쓰이는 extern
어떤 cpp파일에 이미 정의 되어 있는 전역변수를, 다른 cpp에서 가져오려면 extern 키워드를 사용하면 된다. 컴파일은 파일 단위로 하므로 extern 키워드가 앞에 적혀 있으면 해당 파일 내에서 값이 대입되지 않았을지라도 정상적으로 컴파일 하고 넘어간다. 실제 값은 링커 단계에서 들어간다.
<br></br>
<a id="2"></a>
### 업캐스팅과 다운캐스팅
업캐스팅은 부모로 형변환 -> 항상 안전하다.
다운캐스팅은 자식으로 형변환 -> 항상 안전하지 않다.
<br></br>
<a id="3"></a>
### 상속의 메모리적 접근, 업캐스팅이 왜 안전한가?
실제 객체 크기는 그대로 두고, 참조 타입을 부모의 타입로 변환해 실제 접근 가능한 메모리 공간을 제한한다. 다운 캐스팅은 안전하지 않으므로 최대한 쓰지 않는게 좋다.
보통 자식 클래스를 부모 클래스로 치환하다가 다시 자기 형태로 돌아올 때 사용한다.

<br></br>
<a id="4"></a>
### is-a 관계와 has-a 관계
is-a는 부모 자식 관계를 의미한다.
has-a는 말 그대로 소유, 예를 들어 아래처럼 소유 관계의 상속을 의미한다.
class developer : public computer
멤버 변수로 클래스를 갖고 있을 때도 has-a 관계라고 할 수 있다.
즉, 어떤 기능을 사용할 때 물려 받을 수도 있지만 소유할 수 도 있다.
```
class Worker
{
	Worker(Computer* computer)
	: computer(computer) {};

	void Work()
	{
		computer->run();
	}

	Computer* computer = nullptr;
}

int main()
{
	// dependency injection 의존성 주입
	// Dependency Inversion Principle, SOLID 패턴 중 하나
	Computer* computer = new Computer();
	Worker worker = new Worker(computer);
	delete computer;
	computer = nullptr;
}
```
<br></br>
<a id="5"></a>
### cpu가 데이터 접근을 할 때 코드 영역, 데이터 영역, 스택 영역, 힙 영역 어디에 저장되어 있는지 알고 접근을 할까?
모른다. cpu는 주소만 보고 메모리에 접근한다.
컴파일러와 링커 과정에서 코드와 데이터가 분리된다.
```
예)
코드 영역 .text
전역/정적데이터 -> .data, .bss
상수 문자열 -> .rodata
```
그리고 프로세스가 만들어질 때, 운영체제가 가상 주소 공간을 코드 영역, 데이터 영역, 힙 영역, 스택 영역으로 구분한다.

CPU가 가상 메모리 주소로 접근하려 할 때, MMU(Memory Management Unit) 장치가 가상 주소를 실제 물리 주소로 변환한다.
- 스택 오버플로어: os가 스택 끝에 가드 페이지를 둔다. cpu가 스택 오버플로어인지 판단하는게 아니라 os가 막아 놓은 페이지가 침범되면 예외가 터지는 것이다. 
- 가상 메모리 주소 왜 쓰지?

  - 프로세스가 중복된 주소 공간을 쓰더라도 실제 메모리 공간 충돌을 방지할 수 있다.
  - 실제 물리 메모리가 단편화 되어 있더라도 이를 연속적인 것처럼 사용할 수 있게 한다.
  - 메모리 부족시 하드 디스크를 활용하여(스와핑 기술) 메모리 공간을 크게 사용할 수 있다.
  - 메모리 공간을 안전하게 사용할 수 있다. 메모리는 페이지라는 단위로 나눠져 있고, 이 페이지에 대한 정보는 페이지 테이블에 저장되어 있다. 페이지 테이블에는 가상주소, 물리주소, 권한이 적혀 있다. cpu가 메모리로 접근하려 할 때 MMU는 페이지 테이블을 통해 실제 물리주소를 얻어온다. 해당 테이블을 통해 특정 페이지가 쓰기/읽기/실행 중 어떤 권한이 있는지도 확인 가능하다.
<br></br>
<a id="6"></a>
### 참조 타입 / 객체 타입
객체 타입은 실제로 생성된 타입을 이야기하고, 참조 타입은 '바라보는 타입'을 이야기한다. 컴파일은 실제 객체가 어떤 타입이든 참조 타입으로 검사를 하고, 참조 타입에 정의된 멤버만 접근 가능하게 한다.

따라서 아래의 경우에,
```
Entity* entity = new Entity();
Entity* player = new Player();
```
player는 Entity의 멤버에 대해서만 접근이 가능하다. **그러나, Entity에 어떤 함수가 virtual로 선언되고, Player가 이 함수를 override 했을 경우 오버라이드된 함수가 불린다. 그러나!!!! 참조 타입인 Entity에 정의되지 않은 함수는 player를 통해 부를 수 없다.**
<br></br>
<a id="7"></a>
### 참조 타입 / 객체 타입
내용
<br></br>
<a id="8"></a>
### 참조 타입 / 객체 타입
내용
<br></br>
<a id="9"></a>
### 참조 타입 / 객체 타입
내용
<br></br>