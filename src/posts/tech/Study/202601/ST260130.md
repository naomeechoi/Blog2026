---
title: 원티드 수업 (콘솔 엔진 제작: 헤더에 정의를 두었을 때 문제, 렌더링 구조)
date: 2026-01-30T09:07
category: Study
---
## 콘솔 엔진 제작
<details>
<summary><span style="font-size: 25px; font-weight: 700; color: blue">1) 헤더가 정의가 있을 때 생기는 문제</span></summary>

### 헤더에 정의가 있고, 여러 cpp에서 이것을 사용하면 링크단에서 문제가 생긴다.
  - Util.h:
   ```
#pragma once

#include "Math/Vector2.h"
#include "Math/Color.h"

using namespace Wanted;

namespace Util
{
	void SetConsolePosition(const Vector2& position)
	{
		SetConsoleCursorPosition(
			GetStdHandle(STD_OUTPUT_HANDLE),
			static_cast<COORD>(position));
	}

	void SetConsoleTextColor(Color color)
	{
		SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), static_cast<unsigned short>(color));
	}

	void SetCursorVisible(bool bVisible)
	{
		CONSOLE_CURSOR_INFO info = {};
		GetConsoleCursorInfo(GetStdHandle(STD_OUTPUT_HANDLE), &info);
		info.bVisible = bVisible;
		SetConsoleCursorInfo(GetStdHandle(STD_OUTPUT_HANDLE), &info);
	}
}
   ```
 이런 헤더가 있고 Actor.cpp와 Engine.cpp에서 #include "Util/Util.h" 이렇게 유틸헤더를 인클루드하면 링크 오류가 생긴다.
 ```
 1>Engine.obj : error LNK2005: "void __cdecl Util::SetConsolePosition(class Wanted::Vector2 const &)" (?SetConsolePosition@Util@@YAXAEBVVector2@Wanted@@@Z)이(가) Actor.obj에 이미 정의되어 있습니다.
1>Engine.obj : error LNK2005: "void __cdecl Util::SetConsoleTextColor(enum Wanted::Color)" (?SetConsoleTextColor@Util@@YAXW4Color@Wanted@@@Z)이(가) Actor.obj에 이미 정의되어 있습니다.
1>Engine.obj : error LNK2005: "void __cdecl Util::SetCursorVisible(bool)" (?SetCursorVisible@Util@@YAX_N@Z)이(가) Actor.obj에 이미 정의되어 있습니다.
```
그 이유는 헤더는 인클루드 되면 내용을 그대로 복사하는데, 이렇게 하면 정의도 여러개 복사되기 때문이다. 링커 단에서는 중복 정의된 함수 중 어떤 것을 링크해야할 지 알지 못한다. 따라서 이를 해결하려면 1) h에는 선언만 두고 정의를 cpp에 해야한다. cpp는 프로젝트에 딱 한번만 컴파일된다.
2) 혹은 inline 함수화 한다. 이렇게하면 정의가 여러번 있어도 컴파일에서 하나의 함수로 인정한다.
3) static 함수화 한다. 컴파일은 cpp 단위대로 이뤄진다. 따라서 static 함수로 정의하고 헤더를 인클루드하면 cpp 하나당 하나의 static 함수가 생긴다. (해당 번역 단위에서만 보이는 함수가 됨, cpp 별 별개의 스태틱 함수가 생기는 꼴) 동일한 함수임에도 각 cpp에서 다른 함수로 취급되어 코드 길이가 길어짐으로 사용 안 하는 게 좋다.  
</details>

<details>
<summary><span style="font-size: 25px; font-weight: 700; color: blue">2) 렌더링 로직을 만들 때 참고할 수 있는 구조</span></summary>
엑터: 렌더러 컴포넌트 소유, 렌더러 컴포넌트에게 어떻게 그려야 한다고 전달<br>
렌더러 컴포넌트: 전달받은 정보를 기반으로 렌더러 커맨드 만든다.<br>
렌더러 커맨드: 어떤 텍스처를 어디에 그릴지 같은 실제 그리기 정보를 담는다.<br>
렌더러: 렌더러 커맨드 벡터 순회하며 그래픽 API 호출한다.<br>
  
cpu는 작업을 잘게, gpu는 뭉텅이로 해야 성능이 좋아진다.
그래서 한 드로우콜에 많은 정보를 넘겨주는 게 좋다.
자주 보내는 것 자체도 병목.
</details>

<br></br>
## 수업 중 배운 내용 요약
- [X] [constexpr](#1)
- [X] [introsort](#2) -> **삽입정렬, 힙정렬, 퀵정렬 배우고 다시 정리 해야 함**
- [X] [함수객체란](#3) 
- [X] [weak_ptr 왜 쓸까](#3)



<br></br>
<a id="1"></a>
### constexpr
1) 컴파일 타임에 실행될 수 있음을 나타내는 키워드이다. 반드시 컴파일 시간에 실행된다는 보장은 없다.
```
constexpr int* foo() {
    int* p = new int(3);
    return p;
}
```
이 함수의 경우 constexpr가 붙었지만 내부에 동적으로 객체를 생성하는 코드가 있다.
동적 객체의 메모리 공간은 힙에 생성된다.
힙은 동적으로 메모리를 할당하고 해제하는데, 런타임에 요청이 들어오면 메모리 공간을 내어준다.
따라서 이미 주소가 정해져있는 것이 아닌 요청이 올 때 빈 공간을 내어주는 형태이다.

2) constexpr의 역할을 const로도 할 수 있는 경우가 많아졌다. 그러나 이건 컴파일러마다 다르다.
또 템플릿 메타 프로그래밍을 하고 싶을 때 constexpr가 필수인 경우가 있다.
```
#include <iostream>
#include <vector>
#include <list>
#include <iterator>
#include <type_traits>

template<typename Iter>
void advance_iter(Iter& it, int n)
{
    using cat = typename std::iterator_traits<Iter>::iterator_category;

    if (std::is_same_v<cat, std::random_access_iterator_tag>)
    {
        it += n;  // <-- std::list<int>::iterator 에서 컴파일 오류 발생
    }
    else
    {
        while (n--) ++it;
    }
}

int main()
{
    std::vector<int> v{1,2,3,4,5};
    auto itv = v.begin();
    advance_iter(itv, 2); // OK

    std::list<int> l{1,2,3,4,5};
    auto itl = l.begin();
    advance_iter(itl, 2); // :x: 여기서 컴파일 오류

    std::cout << *itl << std::endl;
    return 0;
}
```

위 코드를 보면 list는 임의접근이 안되는 iter를 갖고 있기 때문에 if문에서 에러가 나고 컴파일이 불가하다.
```
if constexpr (std::is_same_v<cat, std::random_access_iterator_tag>)
```
constexpr 키워드를 붙여주면, 컴파일 시간에 조건을 확인하고, 조건 타지 않는 부분은 실행코드에서 삭제해버리는 원리이다. (원래 if는 런타임에 분기)
컴파일 타임에서 list의 advance_iter 함수가 불릴 때
if 구문이 날아가기 때문에 정상적으로 컴파일 가능하다.
<br></br>
<a id="2"></a>
### introsort
the introspective sort (introsort) algorithm as follows:

If the partition size is less than or equal to 16 elements, it uses an insertion sort algorithm.
퀵소트로 분할된 구간의 요소가 16개 이하면 '삽입정렬'을 사용한다.

If the number of partitions exceeds 2 * LogN, where N is the range of the input array, it uses a Heapsort algorithm.
분할된 구간의 개수가 2 * LogN을 초과하 '힙정렬'을 사용한다.

Otherwise, it uses a Quicksort algorithm.
그 외에는 '퀵정렬'을 사용한다.

This method is an O(n log n) operation, where n is length.
시간복잡도는 O(n long n)이다.
<br></br>
<a id="3"></a>
### 함수객체
함수객체는 함수 호출 연산자를 오버로딩한 클래스나 구조체를 말한다.
함수의 상태에 대한 저장이 필요할 때, STL 알고리즘에 커스텀 함수를 넘기고 싶을 때 사용할 수 있다.
람다 함수는 컴파일 과정에서 함수 객체로 변환된다.
람다는 하나의 동작만 정의하지만, 함수 객체는 내부에서 함수 오버로딩이 가능하다(권장되진 않음).
람다의 캡쳐는 함수 객체의 멤버 변수로 변환된다.
<br></br>
<a id="4"></a>
### weak_ptr 왜 쓸까
1) 순환 참조 방지: 플레이어가 없을 때는 존재하지 않아도 되는 던전이 있다고 했을 때, 유저들은 던전의 생명 주기를 관리 해야 함으로 shared_ptr로 던전을 들고 있는다.
던전도 유저들의 정보가 필요할 수 있는데 유저 정보를 shared_ptr로 들고 있는다면 순환참조가 되어 메모리 해제가 정상적으로 이뤄지지 않는다.
던전은 유저들의 생명 주기를 관리할 필요 없으므로 weak_ptr로 유저 정보를 갖으면 된다.  

2) 생명 주기를 관리할 필요 없을 때: 보스 몬스터가 있고 이 보스 몬스터의 상태를 관찰하는 observer들이 있다. 예를 들어 bgm, ui 효과, 카메라 등이 있을 수 있다.
보스 몬스터는 이들에게 자신의 상태를 보내줘야 하는데, 각 요소들의 생명주기를 갖을 필요는 없다. 그럴 때는 weak_ptr로 요소들을 받아 상태를 보내주면 된다.
```
class Subject {
    std::vector<std::weak_ptr<Observer>> observers;

public:
    void AddObserver(std::shared_ptr<Observer> obs) {
        observers.push_back(obs);
    }

    void Notify() {
        for (auto& w : observers) {
            if (auto s = w.lock()) {
                s->Update();
            }
        }
    }
};
```
<br></br>