---
title: 원티드 수업 (콘솔 엔진 제작: 프레임레이트, 키보드인풋)
date: 2026-01-23T09:10
category: Study
---
## 콘솔 엔진 제작
<details>
<summary><span style="font-size: 25px; font-weight: 700; color: blue">1) 프레임 레이트</span></summary>

### 1) 프레임 레이트와 필요성
프레임 레이트는 1초에 화면이 새로 그려지는 횟수 의미한다. 60FPS는 1초에 60프레임이 그려지는 것이다. 프레임 레이트 계산 방식은 여러가지가 있다. 대표적으로 고정 프레임 레이트 계산 방식과 가변 프레임 레이트 계산 방식이 있다.
<br></br>
프레임 레이트는  컴퓨터의 사양을 측정할 수 있는 도구이자 게임 화면을 렌더링하기 위한 기준이 된다. 컴퓨터의 속도는 컴퓨터 마다 다르다. 따라서 프레임 레이트를 고정하면 어떤 컴퓨터에서는 게임이 매우 빠르게 렌더링되고, 어떤 컴퓨터에서는 그렇지 못하다. 예를 들어 고정 프레임 방식으로써, 1/60을 매개 변수에 넣어 1/60 만큼만 처리를 하게 된다고 가정해보자. 성능이 좋은 pc는 다른 pc보다 해당 함수에 들어오는 횟수가 많아진다. 따라서 다른 pc보다 더 많은 길이나 물리량 같은 것이 처리되게 된다. 가변 프레임 방식은 한 사이클이 돌기 까지의 실제 시간을 구해 처리를 한다. 따라서 실제 걸린 시간에 양만큼 처리를 하지만, 이 시간이 매우 길어질 경우에 문제가 생긴다. 일반적으로 렌더링은 가변 프레임에 따라, 물리/로직 업데이트는 고정 타임스텝으로 처리한다.
### 2) 프레임 레이트 계산 방법과 함수
아래 코드는 '가변 프레임 레이트 + 최대 프레임 제한'을 합친 방식이다.
oneFrameTime이 최대 프레임으로 진행된 시간이 oneFrameTime 프레임 이상이 됐을 때 업데이트를 한다. 프레임 레이트가 일정 속도 이상으로 빨라지는 것을 방지한다. QueryPerformanceCounter 함수는 보다 정밀하게 시간을 측정하는 함수로, OS가 실행된 이후부터의 tick을 센다. QueryPerformanceFrequency는 1초에 tick이 몇 번 발생하는 지 리턴한다. (1000번 발생한다면 1초에 1000묶음이 실행되는 것) 따라서 deltaTime = (float)(currentTime - previousTime)을 frequency로 나누면 1000묶음이 몇 개인지 알 수 있고 이게 곧 n초를 의미한다. 
```
	LARGE_INTEGER frequency;
	QueryPerformanceFrequency(&frequency);

	int64_t currentTime = 0;
	int64_t previousTime = 0;

	// 기준 프레임 (단위: 초)
	float targetFrameRate = 120.0f;
	float oneFrameTime = 1.0f / targetFrameRate;

	LARGE_INTEGER time;
	QueryPerformanceCounter(&time);

	// loop 진입 전에는 두 시간을 동일하게 맞춘다.
	currentTime = time.QuadPart;
	previousTime = currentTime;

	while (!isQuit)
	{
		// 현재 시간 계산
		QueryPerformanceCounter(&time);
		currentTime = time.QuadPart;

		// 프레임 시간 계산
		float deltaTime = (float)(currentTime - previousTime);
		// 초단위 변환
		deltaTime /= (float)frequency.QuadPart;

		if (deltaTime >= oneFrameTime)
		{
			// 프레임 처리
			Tick(deltaTime);
			Draw();

			previousTime = currentTime;
		}
	}
```
</details>
<details>
<summary><span style="font-size: 25px; font-weight: 700; color: blue">2) 키보드 인풋</span></summary>

### 1) 키보드 인풋 처리 방법
게임 루프 함수에서 키들의 상태를 확인하여 배열에 담는다.
게임 루프 함수에서 특정 키의 상태를 배열에 접근해 확인한다.
변화가 있을 경우 처리한다.
```
ProcessInput(); // 키 상태 확인하여 배열에 담는 함수
Tick(deltaTime); // 키 입력 확인하여 처리

void Engine::ProcessInput()
{
	// 키 마다의 입력 읽기.
	// 운영체제가 제공하는 기능을 사용할 수 밖에 없다.
	for(int i = 0; i < KEY_RANGE; i++)
		keyStates[i].isKeyDown = GetAsyncKeyState(i) & 0x8000;
}

void Engine::Tick(float deletaTime)
{
	std::cout << "deletaTime: " << deletaTime 
		<< ", FPS: " << (1.0f / deletaTime)
		<< std::endl;

	if (GetKeyDown(VK_ESCAPE))
		QuitEngine();
}
```
</details>

<br></br>
## 수업 중 배운 내용 요약
- [Entity* entity = nullptr; entity->ShowName(); 이 코드는 실행이 될까?](#1)
- [포인터 저장 공간을 nullptr화 시킬 때 주의 사항](#2)
- [타입만 같다면 멤버 함수 안에서 내가 아닌 다른 객체도 수정할 수 있다.](#3)
- [템플릿의 타입은 컴파일 시간에 결정된다.]
- [**전방선언**](#5)
- [상속기반을 쓰려면 인터페이스, 상속기반의 구조가 아니라면 델리게이트를 사용한다.]
- [ ] [델리게이트](https://www.codeproject.com/articles/The-Impossibly-Fast-Cplusplus-Delegates-Fixed#comments-section)



<br></br>
<a id="1"></a>
## Entity* entity = nullptr; entity->ShowName(); 이 코드는 실행이 될까?
```
Entity* entity = nullptr;
entity->ShowName();

// 위는 실행되는 코드다.
// ShowName 함수는 실제 아래처럼 정의된다.
// 따라서 실행에는 문제가 없다.
void ShowName(Entity* entity)
{
	cout << "test << endl;
}

// 그러나 아래는 문제가 된다.
int number = 0; // number은 Entity의 멤버 변수일 경우
void ShowName(Entity* entity)
{
	cout << "test << endl;
	number = 10; /* Entity* entity = nullptr; 이렇게 객체가 정상적으로 생성되지 않았기 때문에 number은 유효하지 않은 변수, 유효하지 않은 변수를 수정하려고 한다.*/
}
```
<br></br>
<a id="2"></a>
### 포인터 저장 공간을 nullptr화 시킬 때 주의 사항
```
for (Player* player : players)
{
	delete player;

	// 이 코드는 문제가 있따. 왜냐면 player라는 복제된 변수를 nullptr화 시킬 뿐이다.
	player = nullptr;
}

// 아래처럼 참조로 접근하거나, 인덱스로 접근해야 안전하다.
for (Player*& player : players)
{
	delete player;
	player = nullptr;
}

for (int i = 0; i < players.size(); i++)
{
	delete player[i];
	player[i] = nullptr;
}
```
<br></br>
<a id="3"></a>
### 타입만 같다면 멤버 함수 안에서 내가 아닌 다른 객체도 수정할 수 있다.
```
#include <iostream>

using namespace std;

class Entity
{
	friend void ShowEntity(Entity& e)
	{
		cout << e.x << ", " << e.y << endl;
	}

public:
	// other은 나와 다른 객체지만 타입이 같아서 수정이 가능하다.
	void ControlAnotherSameTypeObject(Entity& other)
	{
		other.x += 5;
	}

private:
	int x = 1;
	int y = 1;
};


int main()
{
	Entity e1;
	Entity e2;
	e1.ControlAnotherSameTypeObject(e2);

	// 실제로 찍어보면 e2의 x가 변경되어 6, 1 이 나온다.
	ShowEntity(e2);

	return 0;
}
```
<br></br>
<a id="5"></a>
## 전방선언
- 전방선언은 포인터 변수(주소)에 대해서만 허용된다.
- 왜? 헤더파일의 목적 중 하나가, 클래스를 이용하여 객체를 생성할 때 메모리 공간을 얼마나 잡아야하는지 계산하는 토대가 된다. 이때 헤더에 다른 객체를 값으로 들고 있다면 해당 객체가 사용할 메모리 크기를 알아야하기 때문에 그 객체의 헤더를 인클루드 해야한다. 이때 파일 io가 많아지고 전처리후 코드 길이가 길어진다. 그러나 포인터 타입의 객체를 멤버 변수를 갖게 되면, 주소만 저장하면 되기 때문에 해당 객체의 실제 크기를 알 필요가 없다. (참조는 어떻지? 굳이 클래스, 스트럭트 적어줘야할 이유가 있을까?)
<br></br>
